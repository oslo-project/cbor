import { expect, test, describe } from "vitest";
import { decodeCBOR, decodeCBORNoLeftoverBytes } from "./decode.js";
import {
	CBORArray,
	CBORByteString,
	CBORFloat16,
	CBORFloat64,
	CBORLeftoverBytesError,
	CBORMap,
	CBORNegativeInteger,
	CBORNotWellFormedError,
	CBORPositiveInteger,
	CBORSimple,
	CBORTaggedValue,
	CBORTextString,
	CBORTooDeepError
} from "./cbor.js";

describe("decodeCBORNoLeftoverBytes()", () => {
	test("decode indefinite byte string", () => {
		const encoded = new Uint8Array([
			0x5f, 0x43, 0x00, 0x01, 0x02, 0x43, 0x03, 0x04, 0x05, 0x43, 0x06, 0x07, 0x08, 0xff
		]);
		const decoded = decodeCBORNoLeftoverBytes(encoded, 10);
		expect(decoded).toStrictEqual(
			new CBORByteString(new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]))
		);
	});
	test("decode indefinite text string", () => {
		const encoded = new Uint8Array([
			0x7f, 0x65, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x65, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x61, 0x21, 0xff
		]);
		const decoded = decodeCBORNoLeftoverBytes(encoded, 10);
		expect(decoded).toStrictEqual(new CBORTextString(new TextEncoder().encode("helloworld!")));
	});
	test("decode CBOR", () => {
		const encoded = new Uint8Array([
			0xaf, 0x64, 0x74, 0x65, 0x78, 0x74, 0x78, 0x4b, 0x48, 0x61, 0x76, 0x65, 0x20, 0x79, 0x6f,
			0x75, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x61, 0x6c, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2c,
			0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68,
			0x6f, 0x73, 0x65, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65,
			0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c,
			0x79, 0x20, 0x6e, 0x69, 0x67, 0x68, 0x74, 0x73, 0x6c, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
			0x76, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x1b, 0x00, 0x00, 0x00, 0x09, 0x01, 0xc4, 0x90, 0xb8,
			0x6c, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x3b, 0x00,
			0x00, 0x00, 0x09, 0x01, 0xc4, 0x90, 0xb7, 0x01, 0x01, 0x20, 0x20, 0xf9, 0x3c, 0x00, 0xf9,
			0x3c, 0x00, 0x65, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0xfb, 0x40, 0x09, 0x21, 0xfb, 0x4d, 0x12,
			0xd8, 0x4a, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x83, 0x65, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
			0x1a, 0x00, 0x08, 0x4b, 0xb0, 0xa1, 0x67, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x63,
			0x62, 0x79, 0x65, 0x70, 0x69, 0x6e, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x65, 0x5f,
			0x61, 0x72, 0x72, 0x61, 0x79, 0x9f, 0x65, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x1a, 0x00, 0x08,
			0x4b, 0xb0, 0xa1, 0x67, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x63, 0x62, 0x79, 0x65,
			0xff, 0x6e, 0x69, 0x6e, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x61,
			0x70, 0xbf, 0x67, 0x65, 0x6e, 0x67, 0x6c, 0x69, 0x73, 0x68, 0x65, 0x68, 0x65, 0x6c, 0x6c,
			0x6f, 0x68, 0x6a, 0x61, 0x70, 0x61, 0x6e, 0x65, 0x73, 0x65, 0x6f, 0xe3, 0x81, 0x93, 0xe3,
			0x82, 0x93, 0xe3, 0x81, 0xab, 0xe3, 0x81, 0xa1, 0xe3, 0x81, 0xaf, 0x66, 0x66, 0x72, 0x65,
			0x6e, 0x63, 0x68, 0x67, 0x62, 0x6f, 0x6e, 0x6a, 0x6f, 0x75, 0x72, 0x67, 0x73, 0x70, 0x61,
			0x6e, 0x69, 0x73, 0x68, 0x64, 0x68, 0x6f, 0x6c, 0x61, 0xff, 0x63, 0x62, 0x69, 0x67, 0xc2,
			0x4d, 0x30, 0xaf, 0xe2, 0xbf, 0x5e, 0xb8, 0x3b, 0x02, 0xa6, 0xc5, 0xe2, 0x01, 0xab, 0x6c,
			0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x62, 0x69, 0x67, 0xc3, 0x4d, 0x30,
			0xaf, 0xe2, 0xbf, 0x5e, 0xb8, 0x3b, 0x02, 0xa6, 0xc5, 0xe2, 0x01, 0xaa, 0x64, 0x74, 0x72,
			0x75, 0x65, 0xf5, 0x65, 0x66, 0x61, 0x6c, 0x73, 0x65, 0xf4, 0x64, 0x64, 0x61, 0x74, 0x65,
			0xc0, 0x74, 0x32, 0x30, 0x32, 0x30, 0x2d, 0x30, 0x31, 0x2d, 0x30, 0x31, 0x54, 0x30, 0x39,
			0x3a, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x5a
		]);

		const result = decodeCBORNoLeftoverBytes(encoded, 10);
		expect(result).toStrictEqual(
			new CBORMap([
				[
					new CBORTextString(new TextEncoder().encode("text")),
					new CBORTextString(
						new TextEncoder().encode(
							"Have you been alright, through all those lonely lonely lonely lonely nights"
						)
					)
				],
				[
					new CBORTextString(new TextEncoder().encode("positive_int")),
					new CBORPositiveInteger(38684364984n)
				],
				[
					new CBORTextString(new TextEncoder().encode("negative_int")),
					new CBORNegativeInteger(-38684364984n)
				],
				[new CBORPositiveInteger(1n), new CBORPositiveInteger(1n)],
				[new CBORNegativeInteger(-1n), new CBORNegativeInteger(-1n)],
				[
					new CBORFloat16(new Uint8Array([0x3c, 0x00])),
					new CBORFloat16(new Uint8Array([0x3c, 0x00]))
				],
				[
					new CBORTextString(new TextEncoder().encode("float")),
					new CBORFloat64(new Uint8Array([0x40, 0x09, 0x21, 0xfb, 0x4d, 0x12, 0xd8, 0x4a]))
				],
				[
					new CBORTextString(new TextEncoder().encode("array")),
					new CBORArray([
						new CBORTextString(new TextEncoder().encode("hello")),
						new CBORPositiveInteger(543664n),
						new CBORMap([
							[
								new CBORTextString(new TextEncoder().encode("message")),
								new CBORTextString(new TextEncoder().encode("bye"))
							]
						])
					])
				],
				[
					new CBORTextString(new TextEncoder().encode("indefinite_array")),
					new CBORArray([
						new CBORTextString(new TextEncoder().encode("hello")),
						new CBORPositiveInteger(543664n),
						new CBORMap([
							[
								new CBORTextString(new TextEncoder().encode("message")),
								new CBORTextString(new TextEncoder().encode("bye"))
							]
						])
					])
				],
				[
					new CBORTextString(new TextEncoder().encode("indefinite_map")),
					new CBORMap([
						[
							new CBORTextString(new TextEncoder().encode("english")),
							new CBORTextString(new TextEncoder().encode("hello"))
						],
						[
							new CBORTextString(new TextEncoder().encode("japanese")),
							new CBORTextString(new TextEncoder().encode("こんにちは"))
						],
						[
							new CBORTextString(new TextEncoder().encode("french")),
							new CBORTextString(new TextEncoder().encode("bonjour"))
						],
						[
							new CBORTextString(new TextEncoder().encode("spanish")),
							new CBORTextString(new TextEncoder().encode("hola"))
						]
					])
				],
				[
					new CBORTextString(new TextEncoder().encode("big")),
					new CBORTaggedValue(
						2n,
						new CBORByteString(
							new Uint8Array([
								0x30, 0xaf, 0xe2, 0xbf, 0x5e, 0xb8, 0x3b, 0x02, 0xa6, 0xc5, 0xe2, 0x01, 0xab
							])
						)
					)
				],
				[
					new CBORTextString(new TextEncoder().encode("negative_big")),
					new CBORTaggedValue(
						3n,
						new CBORByteString(
							new Uint8Array([
								0x30, 0xaf, 0xe2, 0xbf, 0x5e, 0xb8, 0x3b, 0x02, 0xa6, 0xc5, 0xe2, 0x01, 0xaa
							])
						)
					)
				],
				[new CBORTextString(new TextEncoder().encode("true")), new CBORSimple(21)],
				[new CBORTextString(new TextEncoder().encode("false")), new CBORSimple(20)],
				[
					new CBORTextString(new TextEncoder().encode("date")),
					new CBORTaggedValue(
						0n,
						new CBORTextString(new TextEncoder().encode("2020-01-01T09:00:00Z"))
					)
				]
			])
		);
	});
	test("CBORLeftoverBytesError", () => {
		const encoded = new Uint8Array([
			0xaf, 0x64, 0x74, 0x65, 0x78, 0x74, 0x78, 0x4b, 0x48, 0x61, 0x76, 0x65, 0x20, 0x79, 0x6f,
			0x75, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x61, 0x6c, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2c,
			0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68,
			0x6f, 0x73, 0x65, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65,
			0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c,
			0x79, 0x20, 0x6e, 0x69, 0x67, 0x68, 0x74, 0x73, 0x6c, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
			0x76, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x1b, 0x00, 0x00, 0x00, 0x09, 0x01, 0xc4, 0x90, 0xb8,
			0x6c, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x3b, 0x00,
			0x00, 0x00, 0x09, 0x01, 0xc4, 0x90, 0xb7, 0x01, 0x01, 0x20, 0x20, 0xf9, 0x3c, 0x00, 0xf9,
			0x3c, 0x00, 0x65, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0xfb, 0x40, 0x09, 0x21, 0xfb, 0x4d, 0x12,
			0xd8, 0x4a, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x83, 0x65, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
			0x1a, 0x00, 0x08, 0x4b, 0xb0, 0xa1, 0x67, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x63,
			0x62, 0x79, 0x65, 0x70, 0x69, 0x6e, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x65, 0x5f,
			0x61, 0x72, 0x72, 0x61, 0x79, 0x9f, 0x65, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x1a, 0x00, 0x08,
			0x4b, 0xb0, 0xa1, 0x67, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x63, 0x62, 0x79, 0x65,
			0xff, 0x6e, 0x69, 0x6e, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x61,
			0x70, 0xbf, 0x67, 0x65, 0x6e, 0x67, 0x6c, 0x69, 0x73, 0x68, 0x65, 0x68, 0x65, 0x6c, 0x6c,
			0x6f, 0x68, 0x6a, 0x61, 0x70, 0x61, 0x6e, 0x65, 0x73, 0x65, 0x6f, 0xe3, 0x81, 0x93, 0xe3,
			0x82, 0x93, 0xe3, 0x81, 0xab, 0xe3, 0x81, 0xa1, 0xe3, 0x81, 0xaf, 0x66, 0x66, 0x72, 0x65,
			0x6e, 0x63, 0x68, 0x67, 0x62, 0x6f, 0x6e, 0x6a, 0x6f, 0x75, 0x72, 0x67, 0x73, 0x70, 0x61,
			0x6e, 0x69, 0x73, 0x68, 0x64, 0x68, 0x6f, 0x6c, 0x61, 0xff, 0x63, 0x62, 0x69, 0x67, 0xc2,
			0x4d, 0x30, 0xaf, 0xe2, 0xbf, 0x5e, 0xb8, 0x3b, 0x02, 0xa6, 0xc5, 0xe2, 0x01, 0xab, 0x6c,
			0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x62, 0x69, 0x67, 0xc3, 0x4d, 0x30,
			0xaf, 0xe2, 0xbf, 0x5e, 0xb8, 0x3b, 0x02, 0xa6, 0xc5, 0xe2, 0x01, 0xaa, 0x64, 0x74, 0x72,
			0x75, 0x65, 0xf5, 0x65, 0x66, 0x61, 0x6c, 0x73, 0x65, 0xf4, 0x64, 0x64, 0x61, 0x74, 0x65,
			0xc0, 0x74, 0x32, 0x30, 0x32, 0x30, 0x2d, 0x30, 0x31, 0x2d, 0x30, 0x31, 0x54, 0x30, 0x39,
			0x3a, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x5a, 0x00
		]);
		expect(() => decodeCBORNoLeftoverBytes(encoded, 10)).toThrow(CBORLeftoverBytesError);
	});

	test("CBORNotWellFormedError", () => {
		const encoded = new Uint8Array([0xaf, 0x64, 0x74]);
		expect(() => decodeCBORNoLeftoverBytes(encoded, 10)).toThrow(CBORNotWellFormedError);
	});

	test("CBORTooDeepError", () => {
		let encoded = new Uint8Array([0x81, 0x81, 0x81, 0x81, 0x81, 0x80]);
		expect(() => decodeCBORNoLeftoverBytes(encoded, 5)).not.toThrow(CBORTooDeepError);
		encoded = new Uint8Array([0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x80]);
		expect(() => decodeCBORNoLeftoverBytes(encoded, 5)).toThrow(CBORTooDeepError);
	});
});

test("decodeCBOR()", () => {
	const encoded = new Uint8Array([
		0xaf, 0x64, 0x74, 0x65, 0x78, 0x74, 0x78, 0x4b, 0x48, 0x61, 0x76, 0x65, 0x20, 0x79, 0x6f, 0x75,
		0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x61, 0x6c, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2c, 0x20, 0x74,
		0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x6f, 0x73, 0x65,
		0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6c,
		0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x65, 0x6c, 0x79, 0x20, 0x6e, 0x69, 0x67,
		0x68, 0x74, 0x73, 0x6c, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x69, 0x6e, 0x74,
		0x1b, 0x00, 0x00, 0x00, 0x09, 0x01, 0xc4, 0x90, 0xb8, 0x6c, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69,
		0x76, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x3b, 0x00, 0x00, 0x00, 0x09, 0x01, 0xc4, 0x90, 0xb7, 0x01,
		0x01, 0x20, 0x20, 0xf9, 0x3c, 0x00, 0xf9, 0x3c, 0x00, 0x65, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0xfb,
		0x40, 0x09, 0x21, 0xfb, 0x4d, 0x12, 0xd8, 0x4a, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x83, 0x65,
		0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x1a, 0x00, 0x08, 0x4b, 0xb0, 0xa1, 0x67, 0x6d, 0x65, 0x73, 0x73,
		0x61, 0x67, 0x65, 0x63, 0x62, 0x79, 0x65, 0x70, 0x69, 0x6e, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69,
		0x74, 0x65, 0x5f, 0x61, 0x72, 0x72, 0x61, 0x79, 0x9f, 0x65, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x1a,
		0x00, 0x08, 0x4b, 0xb0, 0xa1, 0x67, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x63, 0x62, 0x79,
		0x65, 0xff, 0x6e, 0x69, 0x6e, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x61,
		0x70, 0xbf, 0x67, 0x65, 0x6e, 0x67, 0x6c, 0x69, 0x73, 0x68, 0x65, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
		0x68, 0x6a, 0x61, 0x70, 0x61, 0x6e, 0x65, 0x73, 0x65, 0x6f, 0xe3, 0x81, 0x93, 0xe3, 0x82, 0x93,
		0xe3, 0x81, 0xab, 0xe3, 0x81, 0xa1, 0xe3, 0x81, 0xaf, 0x66, 0x66, 0x72, 0x65, 0x6e, 0x63, 0x68,
		0x67, 0x62, 0x6f, 0x6e, 0x6a, 0x6f, 0x75, 0x72, 0x67, 0x73, 0x70, 0x61, 0x6e, 0x69, 0x73, 0x68,
		0x64, 0x68, 0x6f, 0x6c, 0x61, 0xff, 0x63, 0x62, 0x69, 0x67, 0xc2, 0x4d, 0x30, 0xaf, 0xe2, 0xbf,
		0x5e, 0xb8, 0x3b, 0x02, 0xa6, 0xc5, 0xe2, 0x01, 0xab, 0x6c, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69,
		0x76, 0x65, 0x5f, 0x62, 0x69, 0x67, 0xc3, 0x4d, 0x30, 0xaf, 0xe2, 0xbf, 0x5e, 0xb8, 0x3b, 0x02,
		0xa6, 0xc5, 0xe2, 0x01, 0xaa, 0x64, 0x74, 0x72, 0x75, 0x65, 0xf5, 0x65, 0x66, 0x61, 0x6c, 0x73,
		0x65, 0xf4, 0x64, 0x64, 0x61, 0x74, 0x65, 0xc0, 0x74, 0x32, 0x30, 0x32, 0x30, 0x2d, 0x30, 0x31,
		0x2d, 0x30, 0x31, 0x54, 0x30, 0x39, 0x3a, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x5a, 0x00
	]);
	expect(decodeCBOR(encoded, 10)[1]).toBe(397);
});
